<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Common Set Representations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/getting_started.html">Getting Started</a></li><li><a class="toctext" href="../man/polyhedral_approximations.html">Polyhedral Approximations</a></li><li><a class="toctext" href="../man/decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="../man/fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="../man/iterative_refinement.html">Iterative refinement</a></li></ul></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="representations.html">Common Set Representations</a><ul class="internal"><li><a class="toctext" href="#Abstract-support-function-and-support-vector-1">Abstract support function and support vector</a></li><li><a class="toctext" href="#Balls-1">Balls</a></li><li><a class="toctext" href="#Polygons-1">Polygons</a></li><li><a class="toctext" href="#Lines-and-linear-constraints-1">Lines and linear constraints</a></li><li><a class="toctext" href="#Hyperrectangles-1">Hyperrectangles</a></li><li><a class="toctext" href="#VoidSets-1">VoidSets</a></li><li><a class="toctext" href="#Singletons-1">Singletons</a></li><li><a class="toctext" href="#Zonotopes-1">Zonotopes</a></li></ul></li><li><a class="toctext" href="operations.html">Common Set Operations</a></li><li><a class="toctext" href="approximations.html">Approximations</a></li><li><a class="toctext" href="utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="representations.html">Common Set Representations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/lib/representations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Common Set Representations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Common-Set-Representations-1" href="#Common-Set-Representations-1">Common Set Representations</a></h1><p>This section of the manual describes the basic set representation types.</p><ul><li><a href="representations.html#Common-Set-Representations-1">Common Set Representations</a></li><ul><li><a href="representations.html#Abstract-support-function-and-support-vector-1">Abstract support function and support vector</a></li><li><a href="representations.html#Balls-1">Balls</a></li><ul><li><a href="representations.html#Euclidean-norm-ball-1">Euclidean norm ball</a></li><li><a href="representations.html#Infinity-norm-ball-1">Infinity norm ball</a></li></ul><li><a href="representations.html#Polygons-1">Polygons</a></li><ul><li><a href="representations.html#Constraint-representation-1">Constraint representation</a></li><li><a href="representations.html#Optimized-constraint-representation-1">Optimized constraint representation</a></li><li><a href="representations.html#Vertex-representation-1">Vertex representation</a></li></ul><li><a href="representations.html#Lines-and-linear-constraints-1">Lines and linear constraints</a></li><li><a href="representations.html#Hyperrectangles-1">Hyperrectangles</a></li><li><a href="representations.html#VoidSets-1">VoidSets</a></li><li><a href="representations.html#Singletons-1">Singletons</a></li><li><a href="representations.html#Zonotopes-1">Zonotopes</a></li></ul></ul><h2><a class="nav-anchor" id="Abstract-support-function-and-support-vector-1" href="#Abstract-support-function-and-support-vector-1">Abstract support function and support vector</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets" href="#LazySets"><code>LazySets</code></a> — <span class="docstring-category">Module</span>.</div><div><p>Main module for <code>LazySets.jl</code> – a Julia package for calculus with convex sets.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/LazySets.jl#L3-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LazySet" href="#LazySets.LazySet"><code>LazySets.LazySet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LazySet</code></pre><p>Abstract type for a lazy set.</p><p><strong>Notes</strong></p><p>Every concrete <code>LazySet</code> must define a function <code>σ(d, X)</code>, representing the support vector of <code>X</code> in a given direction <code>d</code>, and <code>dim</code>, the ambient dimension of the set <code>X</code>.</p><p><code>LazySet</code> types should be parameterized with a type <code>N</code>, typically <code>N&lt;:Real</code>, to support computations with different numeric types.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/LazySets.jl#L16-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.ρ" href="#LazySets.ρ"><code>LazySets.ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ρ(d::AbstractVector{N}, S::LazySet)::N where {N&lt;:Real}</code></pre><p>Evaluate the support function of a set in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>S</code> – convex set</p></li></ul><p><strong>Output</strong></p><p>The support function of the set <code>S</code> for the direction <code>d</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/support_function.jl#L5-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_function" href="#LazySets.support_function"><code>LazySets.support_function</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_function</code></pre><p>Alias for the support function ρ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/support_function.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.support_vector" href="#LazySets.support_vector"><code>LazySets.support_vector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">support_vector</code></pre><p>Alias for the support vector σ.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/support_function.jl#L30-L34">source</a></section><h2><a class="nav-anchor" id="Balls-1" href="#Balls-1">Balls</a></h2><h3><a class="nav-anchor" id="Euclidean-norm-ball-1" href="#Euclidean-norm-ball-1">Euclidean norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Ball2" href="#LazySets.Ball2"><code>LazySets.Ball2</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Ball2{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a ball in the 2-norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the 2-norm is defined as the set</p><div>\[\mathcal{B}_2^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_2 ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_2$</span> denotes the Euclidean norm (also known as 2-norm), defined as <span>$‖ x ‖_2 = \left( \sum\limits_{i=1}^n |x_i|^2 \right)^{1/2}$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create a five-dimensional ball <code>B</code> in the 2-norm centered at the origin with radius 0.5:</p><pre><code class="language-julia-repl">julia&gt; B = Ball2(zeros(5), 0.5)
LazySets.Ball2{Float64}([0.0, 0.0, 0.0, 0.0, 0.0], 0.5)
julia&gt; dim(B)
5</code></pre><p>Evaluate <code>B</code>&#39;s support vector in the direction <span>$[1,2,3,4,5]$</span>:</p><pre><code class="language-julia-repl">julia&gt; σ([1.,2.,3.,4.,5.], B)
5-element Array{Float64,1}:
 0.06742
 0.13484
 0.20226
 0.26968
 0.3371</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Ball2.jl#L3-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Ball2}" href="#LazySets.dim-Tuple{LazySets.Ball2}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(B::Ball2)</code></pre><p>Return the dimension of a ball in the 2-norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the ball.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Ball2.jl#L60-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball2}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Ball2}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{N}, B::Ball2)::AbstractVector{&lt;:AbstractFloat} where {N&lt;:AbstractFloat}</code></pre><p>Return the support vector of a 2-norm ball in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the 2-norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the origin is returned.</p><p><strong>Notes</strong></p><p>Let <code>c</code> and <code>r</code> be the center and radius of a ball <code>B</code> in the 2-norm, respectively. For nonzero direction d, we have <code>σ(d, B) = c + d * (r / ||d||)</code>.</p><p>This function requires computing the 2-norm of the input direction, which is performed in the given precision of the numeric datatype of both the direction and the set. Exact inputs are not supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Ball2.jl#L75-L101">source</a></section><h3><a class="nav-anchor" id="Infinity-norm-ball-1" href="#Infinity-norm-ball-1">Infinity norm ball</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.BallInf" href="#LazySets.BallInf"><code>LazySets.BallInf</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BallInf{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a ball in the infinity norm.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the ball as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real scalar (<span>$≥ 0$</span>)</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a ball in the infinity norm is defined as the set</p><div>\[\mathcal{B}_∞^n(c, r) = \{ x ∈ \mathbb{R}^n : ‖ x - c ‖_∞ ≤ r \},\]</div><p>where <span>$c ∈ \mathbb{R}^n$</span> is its center and <span>$r ∈ \mathbb{R}_+$</span> its radius. Here <span>$‖ ⋅ ‖_∞$</span> denotes the infinity norm, defined as <span>$‖ x ‖_∞ = \max\limits_{i=1,…,n} \vert x_i \vert$</span> for any <span>$x ∈ \mathbb{R}^n$</span>.</p><p><strong>Examples</strong></p><p>Create the two-dimensional unit ball and compute its support function along the positive <span>$x=y$</span> direction:</p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 1.0)
LazySets.BallInf{Float64}([0.0, 0.0], 1.0)
julia&gt; dim(B)
2
julia&gt; ρ([1., 1.], B)
2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L10-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.BallInf}" href="#LazySets.dim-Tuple{LazySets.BallInf}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(B::BallInf)</code></pre><p>Return the dimension of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the ball.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L58-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.BallInf}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.BallInf}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, B::BallInf)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of an infinity norm ball in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – ball in the infinity norm</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L73-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.BallInf}" href="#LazySets.vertices_list-Tuple{LazySets.BallInf}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(B::BallInf{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; B = BallInf(zeros(2), 0.1)
LazySets.BallInf{Float64}([0.0, 0.0], 0.1)
julia&gt; vertices_list(B)
4-element Array{Array{Float64,1},1}:
 [0.1, 0.1]
 [-0.1, 0.1]
 [0.1, -0.1]
 [-0.1, -0.1]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L97-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(B::BallInf, [p]::Real=Inf)::Real</code></pre><p>Return the norm of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of an infinity ball is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L132-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">radius(B::BallInf, [p]::Real=Inf)</code></pre><p>Return the radius of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L155-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(B::BallInf, [p]::Real=Inf)</code></pre><p>Return the diameter of a ball in the infinity norm.</p><p><strong>Input</strong></p><ul><li><p><code>B</code> – ball in the infinity norm</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/BallInf.jl#L177-L197">source</a></section><h2><a class="nav-anchor" id="Polygons-1" href="#Polygons-1">Polygons</a></h2><h3><a class="nav-anchor" id="Constraint-representation-1" href="#Constraint-representation-1">Constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygon" href="#LazySets.HPolygon"><code>LazySets.HPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygon{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints_list</code> – list of linear constraints, sorted by the angle</p></li></ul><p><strong>Notes</strong></p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygon(constraints_list::Vector{LinearConstraint{&lt;:Real}})</code> – default constructor</p></li><li><p><code>HPolygon()</code> – constructor with no constraints</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L9-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.HPolygon{Float64},LazySets.LinearConstraint{Float64}}" href="#LazySets.addconstraint!-Tuple{LazySets.HPolygon{Float64},LazySets.LinearConstraint{Float64}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::HPolygon{N}, constraint::LinearConstraint{N}) where {N&lt;:Real}</code></pre><p>Add a linear constraint to a polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – polygon</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L38-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HPolygon}" href="#LazySets.dim-Tuple{LazySets.HPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::HPolygon)</code></pre><p>Return the dimension of a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L59-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygon}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygon}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::HPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L76-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_contained-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}" href="#LazySets.is_contained-Tuple{AbstractArray{Float64,1},LazySets.HPolygon{Float64}}"><code>LazySets.is_contained</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_contained(x::AbstractVector{&lt;:Real}, P::HPolygon)::Bool</code></pre><p>Return whether a given vector is contained in a polygon.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional vector</p></li><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>Return <code>true</code> iff <span>$x ∈ P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L115-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.HPolygon}" href="#LazySets.tovrep-Tuple{LazySets.HPolygon}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::HPolygon)::VPolygon</code></pre><p>Build a vertex representation of the given polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L138-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.HPolygon}" href="#LazySets.vertices_list-Tuple{LazySets.HPolygon}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::HPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygon.jl#L155-L167">source</a></section><h3><a class="nav-anchor" id="Optimized-constraint-representation-1" href="#Optimized-constraint-representation-1">Optimized constraint representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.HPolygonOpt" href="#LazySets.HPolygonOpt"><code>LazySets.HPolygonOpt</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HPolygonOpt{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a convex polygon in constraint representation whose edges are sorted in counter-clockwise fashion with respect to their normal directions. This is a refined version of <code>HPolygon</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>constraints_list</code> – list of linear constraints</p></li><li><p><code>ind</code> – index in the list of constraints to begin the search to evaluate the          support function</p></li></ul><p><strong>Notes</strong></p><p>This structure is optimized to evaluate the support function/vector with a large sequence of directions that are close to each other. The strategy is to have an index that can be used to warm-start the search for optimal values in the support vector computation.</p><p>The default constructor assumes that the given list of edges is sorted. It <em>does not perform</em> any sorting. Use <code>addconstraint!</code> to iteratively add the edges in a sorted way.</p><ul><li><p><code>HPolygonOpt(constraints_list::Vector{LinearConstraint{&lt;:Real}}, ind::Int64)</code> – default constructor</p></li><li><p><code>HPolygonOpt(constraints_list::Vector{LinearConstraint{&lt;:Real}})</code> – constructor without index</p></li><li><p><code>HPolygonOpt(H::HPolygon{&lt;:Real})</code> – constructor from an HPolygon</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L9-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.addconstraint!-Tuple{LazySets.HPolygonOpt{Float64},LazySets.LinearConstraint{Float64}}" href="#LazySets.addconstraint!-Tuple{LazySets.HPolygonOpt{Float64},LazySets.LinearConstraint{Float64}}"><code>LazySets.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(P::HPolygonOpt{N}, constraint::LinearConstraint{N}) where {N&lt;:Real}</code></pre><p>Add a linear constraint to an optimized polygon in constraint representation, keeping the constraints sorted by their normal directions.</p><p><strong>Input</strong></p><ul><li><p><code>P</code>          – optimized polygon</p></li><li><p><code>constraint</code> – linear constraint to add</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L62-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.HPolygonOpt}" href="#LazySets.dim-Tuple{LazySets.HPolygonOpt}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::HPolygonOpt)</code></pre><p>Return the dimension of an optimized polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the optimized polygon.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L82-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt{Float64}}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::HPolygonOpt{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of an optimized polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. The result is always one of the vertices; in particular, if the direction has norm zero, any vertex is returned.</p><p><strong>Algorithm</strong></p><p>Comparison of directions is performed using polar angles; see the overload of <code>&lt;=</code> for two-dimensional vectors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L99-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.is_contained-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt}" href="#LazySets.is_contained-Tuple{AbstractArray{Float64,1},LazySets.HPolygonOpt}"><code>LazySets.is_contained</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">is_contained(x::AbstractVector{&lt;:Real}, P::HPolygonOpt)::Bool</code></pre><p>Return whether a given vector is contained in an optimized polygon.</p><p><strong>Input</strong></p><ul><li><p><code>x</code> – two-dimensional vector</p></li><li><p><code>P</code> – optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>Return <code>true</code> iff <span>$x ∈ P$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L157-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.tovrep-Tuple{LazySets.HPolygonOpt}" href="#LazySets.tovrep-Tuple{LazySets.HPolygonOpt}"><code>LazySets.tovrep</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">tovrep(P::HPolygonOpt)::VPolygon</code></pre><p>Build a vertex representation of the given optimized polygon.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>The same polygon but in vertex representation, a <code>VPolygon</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L175-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.HPolygonOpt}" href="#LazySets.vertices_list-Tuple{LazySets.HPolygonOpt}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::HPolygonOpt{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of an optimized polygon in constraint representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – an optimized polygon in constraint representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/HPolygonOpt.jl#L192-L205">source</a></section><h3><a class="nav-anchor" id="Vertex-representation-1" href="#Vertex-representation-1">Vertex representation</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VPolygon" href="#LazySets.VPolygon"><code>LazySets.VPolygon</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VPolygon{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a polygon by its vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>vertices_list</code> – the list of vertices</p></li></ul><p><strong>Notes</strong></p><p>The constructor of <code>VPolygon</code> runs a convex hull algorithm, and the given vertices are sorted in counter-clockwise fashion. The constructor flag <code>apply_convex_hull</code> can be used to skip the computation of the convex hull.</p><ul><li><p><code>VPolygon(vertices_list::Vector{Vector{N}};           apply_convex_hull::Bool=true,           algorithm::String=&quot;monotone_chain&quot;)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VPolygon.jl#L7-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.VPolygon}" href="#LazySets.dim-Tuple{LazySets.VPolygon}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(P::VPolygon)</code></pre><p>Return the dimension of a polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the polygon.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VPolygon.jl#L42-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.VPolygon}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.VPolygon}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, P::VPolygon{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a polygon in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>P</code> – polygon in vertex representation</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the first vertex is returned.</p><p><strong>Algorithm</strong></p><p>This implementation performs a brute-force search, comparing the projection of each vector along the given direction. It runs in <span>$O(n)$</span> where <span>$n$</span> is the number of vertices.</p><p><strong>Notes</strong></p><p>For arbitrary points without structure this is the best one can do. However, a more efficient approach can be used if the vertices of the polygon have been sorted in counter-clockwise fashion. In that case a binary search algorithm can be used that runs in <span>$O(\log n)$</span>. See issue <a href="https://github.com/JuliaReach/LazySets.jl/issues/40">#40</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VPolygon.jl#L59-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.VPolygon}" href="#LazySets.vertices_list-Tuple{LazySets.VPolygon}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(P::VPolygon{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the list of vertices of a convex polygon in vertex representation.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polygon vertex representation</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VPolygon.jl#L101-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.singleton_list-Tuple{LazySets.VPolygon}" href="#LazySets.singleton_list-Tuple{LazySets.VPolygon}"><code>LazySets.singleton_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">singleton_list(P::VPolygon{N})::Vector{Singleton{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a convex polygon in vertex representation as a list of singletons.</p><p><strong>Input</strong></p><ul><li><p><code>P</code> – a polygon vertex representation</p></li></ul><p><strong>Output</strong></p><p>List containing a singleton for each vertex.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VPolygon.jl#L118-L131">source</a></section><h2><a class="nav-anchor" id="Lines-and-linear-constraints-1" href="#Lines-and-linear-constraints-1">Lines and linear constraints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.LinearConstraint" href="#LazySets.LinearConstraint"><code>LazySets.LinearConstraint</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">LinearConstraint{N&lt;:Real}</code></pre><p>Type that represents a linear constraint (a half-space) of the form <span>$a⋅x ≤ b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The set <span>$y ≥ 0$</span> in the plane:</p><pre><code class="language-julia-repl">julia&gt; LinearConstraint([0, -1.], 0.)
LazySets.LinearConstraint{Float64}([0.0, -1.0], 0.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/LinearConstraints.jl#L5-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Line" href="#LazySets.Line"><code>LazySets.Line</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Line{N&lt;:Real}</code></pre><p>Type that represents a line in 2D of the form <span>$a⋅x = b$</span>.</p><p><strong>Fields</strong></p><ul><li><p><code>a</code> – normal direction</p></li><li><p><code>b</code> – constraint</p></li></ul><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span>:</p><pre><code class="language-julia-repl">julia&gt; Line([1., 1.], 1.)
LazySets.Line{Float64}([1.0, 1.0], 1.0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/LinearConstraints.jl#L29-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.intersection-Tuple{LazySets.Line{Float64},LazySets.Line{Float64}}" href="#LazySets.intersection-Tuple{LazySets.Line{Float64},LazySets.Line{Float64}}"><code>LazySets.intersection</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersection(L1::Line{N}, L2::Line{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the intersection of two 2D lines.</p><p><strong>Input</strong></p><ul><li><p><code>L1</code> – first line</p></li><li><p><code>L2</code> – second line</p></li></ul><p><strong>Output</strong></p><p>The intersection point, if any. Throws a <code>SingularException</code> if the lines do not intersect.</p><p><strong>Examples</strong></p><p>The line <span>$y = -x + 1$</span> intersected with the line <span>$y = x$</span>:</p><pre><code class="language-julia-repl">julia&gt; intersection(Line([-1., 1.], 0.), Line([1., 1.], 1.))
2-element Array{Float64,1}:
 0.5
 0.5</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/LinearConstraints.jl#L61-L87">source</a></section><h2><a class="nav-anchor" id="Hyperrectangles-1" href="#Hyperrectangles-1">Hyperrectangles</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle" href="#LazySets.Hyperrectangle"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Hyperrectangle{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a hyperrectangle.</p><p>A <a href="https://en.wikipedia.org/wiki/Hyperrectangle">hyperrectangle</a> is the Cartesian product of one-dimensional intervals.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code> – center of the hyperrectangle as a real vector</p></li><li><p><code>radius</code> – radius of the ball as a real vector, i.e., half of its width along             each coordinate direction</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L11-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Hyperrectangle-Tuple{}" href="#LazySets.Hyperrectangle-Tuple{}"><code>LazySets.Hyperrectangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Hyperrectangle(;kwargs...)</code></pre><p>Construct a hyperrectangle from keyword arguments.</p><p><strong>Input</strong></p><ul><li><p><code>kwargs</code> – keyword arguments; two combinations are allowed:</p><ol><li><p><code>center</code>, <code>radius</code> – vectors</p></li><li><p><code>high</code>, <code>low</code>      – vectors (if both <code>center</code> and <code>radius</code> are also                       defined, those are chosen instead)</p></li></ol></li></ul><p><strong>Output</strong></p><p>A hyperrectangle.</p><p><strong>Examples</strong></p><p>The following three constructions are equivalent:</p><pre><code class="language-julia-repl">julia&gt; c = ones(2);

julia&gt; r = [0.1, 0.2];

julia&gt; l = [0.9, 0.8];

julia&gt; h = [1.1, 1.2];

julia&gt; H1 = Hyperrectangle(c, r)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; H2 = Hyperrectangle(center=c, radius=r)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])
julia&gt; H3 = Hyperrectangle(low=l, high=h)
LazySets.Hyperrectangle{Float64}([1.0, 1.0], [0.1, 0.2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L39-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Hyperrectangle}" href="#LazySets.dim-Tuple{LazySets.Hyperrectangle}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(H::Hyperrectangle)</code></pre><p>Return the dimension of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the hyperrectangle.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L91-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Hyperrectangle}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, H::Hyperrectangle)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a hyperrectangle in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>The support vector in the given direction. If the direction has norm zero, the vertex with biggest values is returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L108-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Hyperrectangle}" href="#LazySets.vertices_list-Tuple{LazySets.Hyperrectangle}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(H::Hyperrectangle{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A list of vertices.</p><p><strong>Notes</strong></p><p>For high dimensions, it is preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L127-L143">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.norm" href="#Base.LinAlg.norm"><code>Base.LinAlg.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">norm(H::Hyperrectangle, [p]::Real=Inf)</code></pre><p>Return the norm of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the norm.</p><p><strong>Notes</strong></p><p>The norm of a hyperrectangle is defined as the norm of the enclosing ball, of the given <span>$p$</span>-norm, of minimal volume.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L149-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.radius" href="#LazySets.radius"><code>LazySets.radius</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">radius(H::Hyperrectangle, [p]::Real=Inf)</code></pre><p>Return the radius of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the radius.</p><p><strong>Notes</strong></p><p>The radius is defined as the radius of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L172-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.diameter" href="#LazySets.diameter"><code>LazySets.diameter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diameter(H::Hyperrectangle, [p]::Real=Inf)</code></pre><p>Return the diameter of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li><li><p><code>p</code> – (optional, default: <code>Inf</code>) norm</p></li></ul><p><strong>Output</strong></p><p>A real number representing the diameter.</p><p><strong>Notes</strong></p><p>The diameter is defined as the maximum distance in the given <span>$p$</span>-norm between any two elements of the set. Equivalently, it is the diameter of the enclosing ball of the given <span>$p$</span>-norm of minimal volume with the same center.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L196-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.high-Tuple{LazySets.Hyperrectangle}" href="#LazySets.high-Tuple{LazySets.Hyperrectangle}"><code>LazySets.high</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">high(H::Hyperrectangle)</code></pre><p>Return the higher coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the higher coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L221-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.low-Tuple{LazySets.Hyperrectangle}" href="#LazySets.low-Tuple{LazySets.Hyperrectangle}"><code>LazySets.low</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">low(H::Hyperrectangle)</code></pre><p>Return the lower coordinates of a hyperrectangle.</p><p><strong>Input</strong></p><ul><li><p><code>H</code> – hyperrectangle</p></li></ul><p><strong>Output</strong></p><p>A vector with the lower coordinates of the hyperrectangle, one entry per dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Hyperrectangle.jl#L239-L252">source</a></section><h2><a class="nav-anchor" id="VoidSets-1" href="#VoidSets-1">VoidSets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.VoidSet" href="#LazySets.VoidSet"><code>LazySets.VoidSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">VoidSet &lt;: LazySet</code></pre><p>Type that represents a void (neutral) set with respect to Minkowski sum.</p><p><strong>Fields</strong></p><ul><li><p><code>dim</code> – ambient dimension of the <code>VoidSet</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/VoidSet.jl#L3-L11">source</a></section><h2><a class="nav-anchor" id="Singletons-1" href="#Singletons-1">Singletons</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Singleton" href="#LazySets.Singleton"><code>LazySets.Singleton</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Singleton{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a singleton, that is, a set with a unique element.</p><p><strong>Fields</strong></p><ul><li><p><code>element</code> – the only element of the set</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Singleton.jl#L3-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Singleton}" href="#LazySets.dim-Tuple{LazySets.Singleton}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(S::Singleton)</code></pre><p>Return the dimension of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>S</code> – singleton</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the singleton.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Singleton.jl#L16-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Singleton}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Singleton}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, S::LazySets.Singleton{N})::Vector{N} where {N&lt;:Real}</code></pre><p>Return the support vector of a singleton.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>B</code> – singleton</p></li></ul><p><strong>Output</strong></p><p>The support vector, which is the singleton&#39;s vector itself, irrespective of the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Singleton.jl#L33-L47">source</a></section><h2><a class="nav-anchor" id="Zonotopes-1" href="#Zonotopes-1">Zonotopes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.Zonotope" href="#LazySets.Zonotope"><code>LazySets.Zonotope</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zonotope{N&lt;:Real} &lt;: LazySet</code></pre><p>Type that represents a zonotope.</p><p><strong>Fields</strong></p><ul><li><p><code>center</code>     – center of the zonotope</p></li><li><p><code>generators</code> – matrix; each column is a generator of the zonotope</p></li></ul><p><strong>Notes</strong></p><p>Mathematically, a zonotope is defined as the set</p><div>\[Z = \left\{ c + \sum_{i=1}^p ξ_i g_i,~~ ξ_i \in [-1, 1]~~ ∀ i = 1,…, p \right\},\]</div><p>where <span>$c \in \mathbb{R}^n$</span> is its <em>center</em> and <span>$\{g_i\}_{i=1}^p$</span>, <span>$g_i \in \mathbb{R}^n$</span>, is the set of <em>generators</em>. This characterization defines a zonotope as the finite Minkowski sum of line elements. Zonotopes can be equivalently described as the image of a unit infinity-norm ball in <span>$\mathbb{R}^n$</span> by an affine transformation.</p><ul><li><p><code>Zonotope(center::AbstractVector{N},           generators::AbstractMatrix{N}) where {N&lt;:Real}</code></p></li><li><p><code>Zonotope(center::AbstractVector{N},           generators_list::AbstractVector{T}) where {N&lt;:Real, T&lt;:AbstractVector{N}}</code></p></li></ul><p><strong>Examples</strong></p><p>A two-dimensional zonotope with given center and set of generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope([1.0, 0.0], 0.1*eye(2))
LazySets.Zonotope{Float64}([1.0, 0.0], [0.1 0.0; 0.0 0.1])
julia&gt; dim(Z)
2</code></pre><p>Compute its vertices:</p><pre><code class="language-julia-repl">julia&gt; vertices_list(Z)
4-element Array{Array{Float64,1},1}:
 [0.9, -0.1]
 [1.1, -0.1]
 [1.1, 0.1]
 [0.9, 0.1]</code></pre><p>Evaluate the support vector in a given direction:</p><pre><code class="language-julia-repl">julia&gt; σ([1., 1.], Z)
2-element Array{Float64,1}:
 1.1
 0.1</code></pre><p>Alternative constructor: A zonotope in two dimensions with three generators:</p><pre><code class="language-julia-repl">julia&gt; Z = Zonotope(ones(2), [[1., 0.], [0., 1.], [1., 1.]])
LazySets.Zonotope{Float64}([1.0, 1.0], [1.0 0.0 1.0; 0.0 1.0 1.0])
julia&gt; Z.generators
2×3 Array{Float64,2}:
 1.0  0.0  1.0
 0.0  1.0  1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Zonotope.jl#L5-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.dim-Tuple{LazySets.Zonotope}" href="#LazySets.dim-Tuple{LazySets.Zonotope}"><code>LazySets.dim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dim(Z::Zonotope)</code></pre><p>Return the dimension of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>The ambient dimension of the zonotope.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Zonotope.jl#L85-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Zonotope}" href="#LazySets.σ-Tuple{AbstractArray{Float64,1},LazySets.Zonotope}"><code>LazySets.σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">σ(d::AbstractVector{&lt;:Real}, Z::Zonotope)::AbstractVector{&lt;:Real}</code></pre><p>Return the support vector of a zonotope in a given direction.</p><p><strong>Input</strong></p><ul><li><p><code>d</code> – direction</p></li><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>Support vector in the given direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Zonotope.jl#L100-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.vertices_list-Tuple{LazySets.Zonotope{Float64}}" href="#LazySets.vertices_list-Tuple{LazySets.Zonotope{Float64}}"><code>LazySets.vertices_list</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertices_list(Z::Zonotope{N})::Vector{Vector{N}} where {N&lt;:Real}</code></pre><p>Return the vertices of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>List of vertices.</p><p><strong>Notes</strong></p><p>This implementation computes a convex hull.</p><p>For high dimensions, it would be preferable to develop a <code>vertex_iterator</code> approach.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Zonotope.jl#L118-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazySets.order-Tuple{LazySets.Zonotope}" href="#LazySets.order-Tuple{LazySets.Zonotope}"><code>LazySets.order</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">order(Z::Zonotope)::Rational</code></pre><p>Return the order of a zonotope.</p><p><strong>Input</strong></p><ul><li><p><code>Z</code> – zonotope</p></li></ul><p><strong>Output</strong></p><p>A rational number representing the order of the zonotope.</p><p><strong>Notes</strong></p><p>The order of a zonotope is defined as the quotient of its number of generators and its dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/LazySets.jl/blob/40259e4965d42d79c77a5276d068d3cec1ecdde7/src/Zonotope.jl#L150-L167">source</a></section><footer><hr/><a class="previous" href="../man/iterative_refinement.html"><span class="direction">Previous</span><span class="title">Iterative refinement</span></a><a class="next" href="operations.html"><span class="direction">Next</span><span class="title">Common Set Operations</span></a></footer></article></body></html>
