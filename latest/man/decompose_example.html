<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decomposing an Affine Map · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li><a class="toctext" href="polyhedral_approximations.html">Polyhedral Approximations</a></li><li class="current"><a class="toctext" href="decompose_example.html">Decomposing an Affine Map</a><ul class="internal"><li><a class="toctext" href="#Preliminaries:-Polygon,-Linear-Map,-and-Plotting-1">Preliminaries: Polygon, Linear Map, and Plotting</a></li><li><a class="toctext" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></li><li><a class="toctext" href="#Decomposed-Image-of-a-Linear-Map-1">Decomposed Image of a Linear Map</a></li></ul></li><li><a class="toctext" href="fast_2d_LPs.html">Fast 2D LPs</a></li><li><a class="toctext" href="iterative_refinement.html">Iterative refinement</a></li><li><a class="toctext" href="interval_hulls.html">Interval Hulls</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/representations.html">Common Set Representations</a></li><li><a class="toctext" href="../lib/operations.html">Common Set Operations</a></li><li><a class="toctext" href="../lib/approximations.html">Approximations</a></li><li><a class="toctext" href="../lib/utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="decompose_example.html">Decomposing an Affine Map</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/man/decompose_example.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Decomposing an Affine Map</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Decomposing-an-Affine-Map-1" href="#Decomposing-an-Affine-Map-1">Decomposing an Affine Map</a></h1><p>In this section we present an illustrative example of the <em>decomposed image</em> of a linear map.</p><h2><a class="nav-anchor" id="Preliminaries:-Polygon,-Linear-Map,-and-Plotting-1" href="#Preliminaries:-Polygon,-Linear-Map,-and-Plotting-1">Preliminaries: Polygon, Linear Map, and Plotting</a></h2><p>Let <span>$θ := π/4$</span> and <span>$Φ := \begin{pmatrix} \cos(θ) &amp; -\sin(θ) \\ \sin(θ) &amp; \cos(θ) \end{pmatrix}$</span>.</p><pre><code class="language-julia-repl">julia&gt; theta = pi/4.;

julia&gt; Φ = [cos(theta) -sin(theta); sin(theta) cos(theta)];
</code></pre><p>Now define an arbitrary convex polygon with five vertices with <span>$\operatorname{CH}$</span> denoting the convex hull operation. <span>$\mathcal{X} := \operatorname{CH}\big( (1, 0.5), (1.1, 0.2), (1.4, 0.3), (1.7, 0.5), (1.4, 0.8) \big)$</span></p><pre><code class="language-julia-repl">julia&gt; X = VPolygon([[1.0, 0.5], [1.1, 0.2], [1.4, 0.3], [1.7, 0.5], [1.4, 0.8]])
LazySets.VPolygon{Float64}(Array{Float64,1}[[1.0, 0.5], [1.1, 0.2], [1.4, 0.3], [1.7, 0.5], [1.4, 0.8]])</code></pre><p>Applying the linear map <span>$Φ · \mathcal{X}$</span>, we get a new polygon <span>$\mathcal{X}&#39;$</span> which is the counter-clockwise turn of <span>$\mathcal{X}$</span> by <span>$θ \triangleq 45°$</span>. In this package the linear map is not computed explicitly but only wrapped in a <code>LinearMap</code> instance.</p><pre><code class="language-julia-repl">julia&gt; Xp = Φ * X;

julia&gt; typeof(Xp)
LazySets.LinearMap{LazySets.VPolygon{Float64},Float64}</code></pre><p>Let us plot the two polygons, <span>$\mathcal{X}$</span> in green and <span>$\mathcal{X}&#39;$</span> in blue.</p><pre><code class="language-julia-repl">julia&gt; using Plots;

julia&gt; plot(X, color=&quot;green&quot;)

julia&gt; plot!(Xp, 1e-2, color=&quot;blue&quot;)
</code></pre><p>Note that we have passed <code>1e-2</code> as additional argument for the <code>LinearMap</code> set (<span>$\mathcal{X}&#39;$</span>) because by default such a set is just plotted as its box (or hyperrectangle) approximation. The value <code>1e-2</code> is the precision up to which the set is (over-)approximated with a polgon, which in this case is sufficient to obtain the actual set again.</p><p><img src="../assets/linmap_deco_1.png" alt="../assets/linmap_deco_1.png"/></p><h2><a class="nav-anchor" id="Cartesian-Decomposition-1" href="#Cartesian-Decomposition-1">Cartesian Decomposition</a></h2><p>Next we want to decompose <span>$\mathcal{X}$</span> into a Cartesian product of intervals. That is, we project it to the x-axis and y-axis and then compose these intervals again: <span>$\hat{\mathcal{X}} := \hat{\mathcal{X}}_1 \times \hat{\mathcal{X}}_2$</span>.</p><pre><code class="language-julia-repl">julia&gt; Xhat = overapproximate(X);

julia&gt; plot(Xhat, color=&quot;gray&quot;, alpha=0.3)

julia&gt; plot!(X, color=&quot;green&quot;)

julia&gt; plot!(Xp, 1e-2, color=&quot;blue&quot;)
</code></pre><p><img src="../assets/linmap_deco_2.png" alt="../assets/linmap_deco_2.png"/></p><h2><a class="nav-anchor" id="Decomposed-Image-of-a-Linear-Map-1" href="#Decomposed-Image-of-a-Linear-Map-1">Decomposed Image of a Linear Map</a></h2><p>Now let us compute the linear map for the box approximation, and let us call it <span>$\mathcal{Y} := Φ · \hat{\mathcal{X}}$</span>. This will be a diamond-like shape (the box turned by <code>45°</code>).</p><pre><code class="language-julia-repl">julia&gt; Xphat = Φ * Xhat;

julia&gt; plot(Xhat, color=&quot;gray&quot;, alpha=0.3)

julia&gt; plot!(X, color=&quot;green&quot;)

julia&gt; plot!(Xphat, 1e-2, color=&quot;yellow&quot;, alpha=0.3)

julia&gt; plot!(Xp, 1e-2, color=&quot;blue&quot;)
</code></pre><p><img src="../assets/linmap_deco_3.png" alt="../assets/linmap_deco_3.png"/></p><p>However, we want our approximation be again a Cartesian product of intervals, so we have to overapproximate this diamond-like shape again: <span>$\hat{\mathcal{Y}} = \hat{\mathcal{X}}&#39; = \hat{\mathcal{X}}_1&#39; \times \hat{\mathcal{X}}_2&#39;$</span></p><pre><code class="language-julia-repl">julia&gt; Xhatp = overapproximate(Xphat);

julia&gt; plot(Xhat, color=&quot;gray&quot;, alpha=0.3)

julia&gt; plot!(X, color=&quot;green&quot;)

julia&gt; plot!(Xhatp, 1e-2, color=&quot;gray&quot;, alpha=0.3)

julia&gt; plot!(Xphat, 1e-2, color=&quot;yellow&quot;, alpha=0.3)

julia&gt; plot!(Xp, 1e-2, color=&quot;blue&quot;)
</code></pre><p><img src="../assets/linmap_deco_4.png" alt="../assets/linmap_deco_4.png"/></p><p>As we can see, the resulting box <span>$\hat{\mathcal{X}}&#39;$</span> is <em>not</em> a tight overapproximation of <span>$\mathcal{X}&#39;$</span>. We can, however, gain precision by reducing the angle by which we turn the set, e.g., making two smaller turns. Why not try it out?</p><footer><hr/><a class="previous" href="polyhedral_approximations.html"><span class="direction">Previous</span><span class="title">Polyhedral Approximations</span></a><a class="next" href="fast_2d_LPs.html"><span class="direction">Next</span><span class="title">Fast 2D LPs</span></a></footer></article></body></html>
