<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polyhedral Approximations · LazySets.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LazySets.jl logo"/></a><h1>LazySets.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li class="current"><a class="toctext" href="polyhedral_approximations.html">Polyhedral Approximations</a><ul class="internal"><li><a class="toctext" href="#Preliminaries-1">Preliminaries</a></li><li><a class="toctext" href="#Support-Function-1">Support Function</a></li><li><a class="toctext" href="#Support-Vector-1">Support Vector</a></li></ul></li><li><a class="toctext" href="decompose_example.html">Decomposing an Affine Map</a></li><li><a class="toctext" href="fast_2d_LPs.html">Fast 2D LPs</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/representations.html">Common Set Representations</a></li><li><a class="toctext" href="../lib/operations.html">Common Set Operations</a></li><li><a class="toctext" href="../lib/approximations.html">Approximations</a></li><li><a class="toctext" href="../lib/utils.html">Utility Functions</a></li></ul></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="polyhedral_approximations.html">Polyhedral Approximations</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/LazySets.jl/blob/master/docs/src/man/polyhedral_approximations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Polyhedral Approximations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Polyhedral-Approximations-1" href="#Polyhedral-Approximations-1">Polyhedral Approximations</a></h1><p>Polyhedral Approximation of a Convex Set</p><h2><a class="nav-anchor" id="Preliminaries-1" href="#Preliminaries-1">Preliminaries</a></h2><p>Let us introduce some notation. Let <span>$\mathbb{I}_n$</span> be the identity matrix of dimension <span>$n\times n$</span>. For <span>$p \geq 1$</span>, the <span>$p$</span>-norm of an <span>$n$</span>-dimensional vector <span>$x \in \mathbb{R}^n$</span> is denoted  <span>$\Vert x \Vert_p$</span>.</p><h2><a class="nav-anchor" id="Support-Function-1" href="#Support-Function-1">Support Function</a></h2><p>The support function is a basic notion for approximating convex sets. Let <span>$\mathcal{X} \subset \mathbb{R}^n$</span> be a compact convex set. The <em>support function</em> of <span>$\mathcal{X}$</span> is the function <span>$\rho_\mathcal{X} : \mathbb{R}^n\to \mathbb{R}$</span>, defined as</p><div>\[\rho_\mathcal{X}(\ell) := \max\limits_{x \in \mathcal{X}} \ell^\mathrm{T} x.\]</div><p>We recall the following elementary properties of the support function.</p><p><strong>Proposition.</strong> For all compact convex sets <span>$\mathcal{X}$</span>, <span>$\mathcal{Y}$</span> in <span>$\mathbb{R}^n$</span>, for all <span>$n\times n$</span> real matrices <span>$M$</span>, all scalars <span>$\lambda$</span>, and all vectors <span>$\ell \in \mathbb{R}^n$</span>, we have:</p><p>(1.1) <span>$\rho_{\lambda\mathcal{X}} (\ell) = \rho_{\mathcal{X}} (\lambda \ell)$</span>, and         <span>$\rho_{\lambda\mathcal{X}} (\ell) = \lambda \rho_{\mathcal{X}} (\ell)$</span> if <span>$\lambda &gt; 0$</span>.</p><p>(1.2) <span>$\rho_{M\mathcal{X}} (\ell) = \rho_{\mathcal{X}} (M^\mathrm{T} \ell)$</span></p><p>(1.3) <span>$\rho_{\mathcal{X} \oplus \mathcal{Y}} (\ell) = \rho_{\mathcal{X}} (\ell) + \rho_{\mathcal{Y}} (\ell)$</span></p><p>(1.4) <span>$\rho_{\mathcal{X} \times \mathcal{Y}} (\ell) = \ell^\mathrm{T} \sigma_{\mathcal{X} \times \mathcal{Y}}(\ell)$</span></p><p>(1.5) <span>$\rho_{\mathrm{CH}(\mathcal{X}\cup\mathcal{Y})} (\ell) = \max (\rho_{\mathcal{X}} (\ell), \rho_{\mathcal{Y}} (\ell))$</span></p><h2><a class="nav-anchor" id="Support-Vector-1" href="#Support-Vector-1">Support Vector</a></h2><p>The farthest points of <span>$\mathcal{X}$</span> in the direction <span>$\ell$</span>  are the <em>support vectors</em> denoted <span>$\sigma_\mathcal{X}(\ell)$</span>. These points correspond to the optimal points for the support function, i.e.,</p><div>\[\sigma_\mathcal{X}(\ell) := \{ x \in \mathcal{X} : \ell^\mathrm{T} x  = \rho_{\mathcal{X}}(\ell)  \}.\]</div><p>Since all support vectors in a given direction evaluate to the same value of the support function, we often speak of <em>the support vector</em>, where the choice of any support vector is implied.</p><p><img src="../assets/sfun_svec.png" alt="Illustration of the support function and the support vector"/></p><p><strong>Proposition 2.</strong> Under the same conditions as in Proposition 1, the following hold:</p><p>(2.1) <span>$\sigma_{\lambda\mathcal{X}} (\ell) = \lambda \sigma_{\mathcal{X}} (\lambda \ell)$</span></p><p>(2.2) <span>$\sigma_{M\mathcal{X}} (\ell) = M\sigma_{\mathcal{X}} (M^\mathrm{T} \ell)$</span></p><p>(2.3) <span>$\sigma_{\mathcal{X} \oplus \mathcal{Y}} (\ell) = \sigma_{\mathcal{X}} (\ell) \oplus \sigma_{\mathcal{Y}} (\ell)$</span></p><p>(2.4) <span>$\sigma_{\mathcal{X} \times \mathcal{Y}} (\ell) = (\sigma_{\mathcal{X}}(\ell_1), \sigma_{\mathcal{Y}}(\ell_2)), \ell = (\ell_1, \ell_2)$</span></p><p>(2.5) <span>$\sigma_{\mathrm{CH}(\mathcal{X}\cup\mathcal{Y})} (\ell) = \text{argmax}_{x, y} (\ell^\mathrm{T} x, \ell^\mathrm{T} y)$</span>,       where <span>$x \in \sigma_{\mathcal{X}}(\ell), y \in \sigma_{\mathcal{Y}}(\ell)$</span></p><footer><hr/><a class="previous" href="getting_started.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a><a class="next" href="decompose_example.html"><span class="direction">Next</span><span class="title">Decomposing an Affine Map</span></a></footer></article></body></html>
